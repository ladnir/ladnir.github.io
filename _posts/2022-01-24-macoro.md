---
layout: post
title: "Back Porting C++20 Coroutines to C++14 -- A Tutorial"
excerpt_separator: <!--more-->
categories:
  - Blog
tags:
  - cpp
  - coroutine
---
# C++14/20 Coroutines

The aim of this post is to given another perspective on the C++20 coroutine specification by presenting a small library that implements coroutines using C++14 and a couple macros to aid readability. For example, the following two function `g20()`, `g14()` both implementation the same coroutine functionality. While the C++20 version is clearly a bit simpler, both are functionally equivalent and sufficiently readable. Next we will unpack what the ''coroutine transformation'' is and how it we can [partially] implement it without specialized compiler support.

<!-- ```c++
my_future<int>  h();

// C++20 version
my_future<int> g1()
{
  int i = co_await h();
  if(i == 42)
    i = 0;
  co_return i;
}

// C++14 version
my_future<int> g2()
{
  // Specify the return type any lambda capture and local variables.
  CO_BEGIN(my_future<int>, i = int{});

  // assign the result of h() to i
  CO_AWAIT(i, h());
  if(i == 42)
    i = 0;
  CO_RETURN(i);

  CO_END();
}
``` -->
<pre style="font-family:Consolas;font-size:13px;color:gainsboro;background:#222222;"><span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>&nbsp;&nbsp;<span style="color:#dcdcaa;">h</span><span style="color:#b4b4b4;">();</span>
 
<span style="color:#57a64a;">//&nbsp;C++20&nbsp;version</span>
<span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>&nbsp;<span style="color:#dcdcaa;">g20</span><span style="color:#b4b4b4;">()</span>
<span style="color:#b4b4b4;">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">int</span>&nbsp;<span style="color:#9cdcfe;">i</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#d8a0df;">co_await</span>&nbsp;<span style="color:#dcdcaa;">h</span><span style="color:#b4b4b4;">();</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">i</span>&nbsp;<span style="color:#b4b4b4;">==</span>&nbsp;<span style="color:#b5cea8;">42</span><span style="color:#b4b4b4;">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#9cdcfe;">i</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b5cea8;">0</span><span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">co_return</span>&nbsp;<span style="color:#9cdcfe;">i</span><span style="color:#b4b4b4;">;</span>
<span style="color:#b4b4b4;">}</span>
 
<span style="color:#57a64a;">//&nbsp;C++14&nbsp;version</span>
<span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>&nbsp;<span style="color:#dcdcaa;">g14</span><span style="color:#b4b4b4;">()</span>
<span style="color:#b4b4b4;">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;Specify&nbsp;the&nbsp;return&nbsp;type&nbsp;and&nbsp;lambda&nbsp;capture&nbsp;any&nbsp;local&nbsp;variables.</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#beb7ff;">CO_BEGIN</span><span style="color:#b4b4b4;">(</span><span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;,</span>&nbsp;i&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">{});</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;assign&nbsp;the&nbsp;result&nbsp;of&nbsp;h()&nbsp;to&nbsp;i</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#beb7ff;">CO_AWAIT</span><span style="color:#b4b4b4;">(</span><span style="color:#dadada;">i</span><span style="color:#b4b4b4;">,</span>&nbsp;<span style="color:#dcdcaa;">h</span><span style="color:#b4b4b4;">());</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#dadada;">i</span>&nbsp;<span style="color:#b4b4b4;">==</span>&nbsp;<span style="color:#b5cea8;">42</span><span style="color:#b4b4b4;">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#dadada;">i</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b5cea8;">0</span><span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#beb7ff;">CO_RETURN</span><span style="color:#b4b4b4;">(</span><span style="color:#dadada;">i</span><span style="color:#b4b4b4;">);</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#beb7ff;">CO_END</span><span style="color:#b4b4b4;">();</span>
<span style="color:#b4b4b4;">}</span>
</pre>

Due to certain limitations of macros, etc., all local variables that span a  <span style="color:#beb7ff;">CO_XXXX</span> macro must be "lambda captured" in the <span style="color:#beb7ff;">CO_BEGIN</span> macro. We will discuss this more below but <span style="color:#beb7ff;">CO_BEGIN</span> must be passed the return type followed by the body of a lambda capture as if the rest of the code is in a lambda that can not have local variables. For example, <span style="color:#beb7ff;">CO_END</span>(<span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>, i = <span style="color:#569cd6;">int</span>{}); loosely gets translated into
```C++
[i = int{}]() -> my_future<int> {
  <body-of-the-coroutine>
}
```
This likely gives the reader a hint at how we will port C++20 coroutines back to C++14.

## Coroutine Useage
First, let us review some basic coroutine functionality. If the reader is familiar with coroutines feel free to skip to the next section. Coroutines can be thought of as a stateful function that can "pause" its execution and then be resumed later by the caller or someone else.

###   <span style="color:#d8a0df;">co_await</span>
There are a couple situations where a coroutine might be pause, or "suspend" in coroutine terminology. The most common is when the coroutine body contains a   <span style="color:#d8a0df;">co_await</span> call of some [awaitable](https://en.cppreference.com/w/cpp/language/coroutines#co_await) (e.g. some other coroutine) and the result is not ready yet. For example, in the functions above we call <span style="color:#d8a0df;">co_await</span>` h()`. The function `h()` returns a <span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span> which implements the interface of an "awaitable" with value type <span style="color:#569cd6;">int</span>. This interface allows the compiler to auto generate some code that determines if the underlying value is ready now or if the caller should suspend while we wait for the value. 

To make the example a bit more concrete, `h()` could be fetching a value from some server on the internet which is slow. While we wait, we want to pause this coroutine and allow the caller to go do something else. Onces the value arrives, the coroutine can be resumed by the completion of `h()`, on possibly some other thread or we can be notified in some way and manually resume the coroutine. The how/when/who resumes the coroutine can be customized by our return type <span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span> and what we are   <span style="color:#d8a0df;">co_await</span>ing on.

If the underlying <span style="color:#569cd6;">int</span> that is provided by `h()` is ready immidiately, our coroutine does not need to suspend. 
Whenever the underlying value is ready, either immidiately after the call to `h()` or when the coroutine is resumed, execution of the coroutine continues. The next thing to be executed is compiler generated code that passes the value held in the <span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span> to the current coroutine, i.e. assigns it to <span style="color:#569cd6;">int</span>` i` in our examples. More details on this compiler generated code later. Finally, execution of the coroutine continues with the next statement after the   <span style="color:#d8a0df;">co_await</span>.

### <span style="color:#d8a0df;">co_yield</span>
Another example of when a coroutine can be suspended is with the <span style="color:#d8a0df;">co_yield</span> keyword. The exact symantics of this is customizable but typically it is used to suspend the current coroutine and pass a value back to the caller. This is similar to returning a value but that we are allowed to resume the coroutine later. Typically, the caller will use this value and then resume to coroutine which can <span style="color:#d8a0df;">co_yield</span> another value back to the caller or run to completion. A classic example of this is to lazily generate a range of values. For example, `range20`,`range14` both return a <span style="color:#4ec9b0;">my_range</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span> which allows the caller to iterate over the values that are <span style="color:#d8a0df;">co_yield</span> out of the coroutine. This example prints the string `2,3,4,5,6,7,8,9,`.
```C++
my_range<int> range20(int begin, int end) {
  for(int i = begin; i < end; ++i)
    co_yield i;
}
my_range<int> range14(int begin, int end) {
  CO_BEGIN(my_range<int>, begin, end, i = int{});
  for(i = begin; i < end; ++i)
    CO_YIELD(i);
  CO_END();
}

void example() {
  for(int i : range14(2, 10))
    std::cout << i <<',';
}
```
Importantly, the return type of the coroutine, in this case <span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>, must implement a certain interface in order for the coroutine body to interact with it. In breif, this interface consists of the return type having an associated <span style="color:#4ec9b0;">promise_type</span> which implements certain function. For <span style="color:#d8a0df;">co_yield</span>` <expr>;` statements the `<expr>` value that is yielded is forwarded to <span style="color:#4ec9b0;">promise_type</span>::`yield_value(<expr>)` which, in our example, somehow forwards it to the return value <span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span> so that the caller can consume it. Similar "customization points" are required for determining how the other situations are handled.

### <span style="color:#d8a0df;">co_return</span>
To return a value from a coroutine we must use <span style="color:#d8a0df;">co_return</span> instead of normal <span style="color:#d8a0df;">return</span>. This special return keywork helps the compiler know that the current function is a coroutine as opposed to a normal function. In particular, from the function signature <span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>` g20();` there is no way to tell of the body of the function is coroutine or a normal function that just happens to return a <span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>. 

More generally, whenever the compiler sees at least one   <span style="color:#d8a0df;">co_await</span>, <span style="color:#d8a0df;">co_yield</span> or <span style="color:#d8a0df;">co_return</span> keyword, it will convert the function body into a coroutine by performing the "coroutine transformation." Importantly, this transformation is just an implementation detail. The caller does not know or care if <span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>` g20();` is a coroutine or implements the required logic in some other way.

Next we will discuss percisely that, how to implement the coroutine transformation manually and then introduce the macros you see above to aid readability.

## The Coroutine Transformation

At the core of the coroutine specification relatively mechanical transformation. Every coroutine function is effectively transformed into two functions. The first performs the following:
- Constructs the so-called promise type <span style="color:#4ec9b0;">&lt;function-return-type&gt;</span>::<span style="color:#4ec9b0;">promise_type</span>` promise`. The role of the promise type is to decide when to start and/or resume the coroutine and what to do when it yields a value or returns.
- Construct the return type<span style="color:#4ec9b0;">&lt;function-return-type&gt;</span> which in our first example is <span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>. This is obtained by calling <span style="color:#4ec9b0;">promise_type</span>`.get_return_object()`. This will be what is returned to the caller.
- Query the <span style="color:#4ec9b0;">promise_type</span> and decide if the coroutine body should be started now (before returning to the caller) or later (possibly by the caller). This is determined by the result of <span style="color:#4ec9b0;">promise_type</span>`.initial_suspend()`. If we should start now then we call the second function.
- Finally we return the the result of <span style="color:#4ec9b0;">promise_type</span>`.get_return_object()` to the caller.

The second function of the transformation will contain the actual body of the coroutine that the user wrote. Each time   <span style="color:#d8a0df;">co_await</span>, <span style="color:#d8a0df;">co_yield</span> or <span style="color:#d8a0df;">co_return</span> is seen, code in inserted to perform the required logic and allow the coroutine to be suspended/resumed at this location. These are called suspension points.

Below is some C++ inspired pseudocode that loosely implements the required logic which we explain next. The function `g_inlined` is indended to have the same behavious as `g20`, `g14` above.

<pre style="font-family:Consolas;font-size:13px;color:gainsboro;background:#1e1e1e;"><span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>&nbsp;<span style="color:#dcdcaa;">g_inlined</span><span style="color:#b4b4b4;">()</span>
<span style="color:#b4b4b4;">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;Construct&nbsp;the&nbsp;coroutine&nbsp;frame&nbsp;and&nbsp;promise</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">struct</span>&nbsp;<span style="color:#4ec9b0;">coroutine_frame</span>&nbsp;<span style="color:#b4b4b4;">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;::</span><span style="color:#4ec9b0;">promise_type</span>&nbsp;<span style="color:#dadada;">promise</span><span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#c8c8c8;">std</span><span style="color:#b4b4b4;">::</span><span style="color:#4ec9b0;">function</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">void</span><span style="color:#b4b4b4;">(</span><span style="color:#569cd6;">void</span><span style="color:#b4b4b4;">)&gt;</span>&nbsp;<span style="color:#dadada;">body</span><span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#b4b4b4;">};</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">auto</span>&nbsp;<span style="color:#9cdcfe;">frame</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#569cd6;">new</span>&nbsp;<span style="color:#4ec9b0;">coroutine_frame</span><span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">auto</span><span style="color:#b4b4b4;">&amp;</span>&nbsp;<span style="color:#9cdcfe;">promise</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">frame</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dadada;">promise</span><span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">my_future</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">int</span><span style="color:#b4b4b4;">&gt;</span>&nbsp;<span style="color:#9cdcfe;">ret</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">promise</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">get_return_object</span><span style="color:#b4b4b4;">();</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;define&nbsp;the&nbsp;function&nbsp;body</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#9cdcfe;">frame</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dadada;">body</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">[&amp;,</span>&nbsp;<span style="color:#dadada;">suspend_address</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">&amp;</span>InitialSuspend<span style="color:#b4b4b4;">]()</span>&nbsp;<span style="color:#b4b4b4;">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;jump&nbsp;to&nbsp;wherever&nbsp;we&nbsp;left&nbsp;off.</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">goto</span>&nbsp;<span style="color:#c8c8c8;">suspend_address</span><span style="color:#b4b4b4;">;</span>
<span style="color:#c8c8c8;">InitialSuspend</span><span style="color:#b4b4b4;">:</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;&lt;----&nbsp;begining&nbsp;of&nbsp;user&nbsp;code.&nbsp;----&gt;</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;int&nbsp;i&nbsp;=&nbsp;co_await&nbsp;h();</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">auto</span>&nbsp;<span style="color:#9cdcfe;">awaiter_h</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#dcdcaa;">h</span><span style="color:#b4b4b4;">();</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(!</span><span style="color:#9cdcfe;">awaiter_h</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">await_ready</span><span style="color:#b4b4b4;">())</span>&nbsp;<span style="color:#b4b4b4;">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#dadada;">suspend_address</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">&amp;</span>Suspend_1<span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#9cdcfe;">awaiter_h</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">await_suspend</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">frame</span><span style="color:#b4b4b4;">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">return</span><span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#b4b4b4;">}</span>
<span style="color:#c8c8c8;">Suspend_1</span><span style="color:#b4b4b4;">:</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">int</span>&nbsp;<span style="color:#9cdcfe;">i</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#9cdcfe;">awaiter_h</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">await_resume</span><span style="color:#b4b4b4;">();</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;normal&nbsp;code</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">i</span>&nbsp;<span style="color:#b4b4b4;">==</span>&nbsp;<span style="color:#b5cea8;">42</span><span style="color:#b4b4b4;">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#9cdcfe;">i</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b5cea8;">0</span><span style="color:#b4b4b4;">;</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;co_return&nbsp;i;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#dadada;">suspend_address</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">&amp;</span>FinalSuspend<span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#9cdcfe;">promise</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">return_value</span><span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">i</span><span style="color:#b4b4b4;">);</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;&lt;----&nbsp;end&nbsp;of&nbsp;user&nbsp;code.&nbsp;----&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;final&nbsp;suspend</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(!</span><span style="color:#9cdcfe;">promise</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">final_suspend</span><span style="color:#b4b4b4;">().</span><span style="color:#dcdcaa;">await_ready</span><span style="color:#b4b4b4;">())</span>&nbsp;<span style="color:#b4b4b4;">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#dadada;">suspend_address</span>&nbsp;<span style="color:#b4b4b4;">=</span>&nbsp;<span style="color:#b4b4b4;">&amp;</span>FinalSuspend<span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">return</span><span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#b4b4b4;">}</span>
<span style="color:#c8c8c8;">FinalSuspend</span><span style="color:#b4b4b4;">:</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">delete</span>&nbsp;<span style="color:#9cdcfe;">frame</span><span style="color:#b4b4b4;">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#b4b4b4;">};</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#57a64a;">//&nbsp;call&nbsp;the&nbsp;coroutine&nbsp;body&nbsp;if&nbsp;we&nbsp;are&nbsp;ready.</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">if</span>&nbsp;<span style="color:#b4b4b4;">(</span><span style="color:#9cdcfe;">promise</span><span style="color:#b4b4b4;">.</span><span style="color:#dcdcaa;">initial_suspend</span><span style="color:#b4b4b4;">().</span><span style="color:#dcdcaa;">await_ready</span><span style="color:#b4b4b4;">())</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#9cdcfe;">frame</span><span style="color:#b4b4b4;">-&gt;</span><span style="color:#dadada;">body</span><span style="color:#b4b4b4;">()</span><span style="color:#b4b4b4;">;</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#d8a0df;">return</span>&nbsp;<span style="color:#9cdcfe;">ret</span><span style="color:#b4b4b4;">;</span>
<span style="color:#b4b4b4;">}</span></pre>

First the so-called <span style="color:#4ec9b0;">coroutine_frame</span> is allocated. The frame will contain the <span style="color:#4ec9b0;">promise_type</span> and space for the local variables used in the function body, which for clarity is being managed using <span style="color:#c8c8c8;">std</span><span style="color:#b4b4b4;">::</span><span style="color:#4ec9b0;">function</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">void</span><span style="color:#b4b4b4;">(</span><span style="color:#569cd6;">void</span><span style="color:#b4b4b4;">)&gt;</span>. 

This function body can be called many times with the desired logic begining that the function should resume from wherever it left off. The code above acheives this using a hypethetical syntax for storing the addresses of `goto` labels. In particular, each time we enter the function body we will perform `goto suspend_address` where `suspend_address` is the location in the function that is just after where we suspended last. 

The first time we enter the function `suspend_address` will have the inital value of `InitialSuspend:` and begin executing the user code. At some point the execution will hit a `co_*` statement, in this case `int i = co_await h();`. This statement will be transformed as shown to first query if the value return by `auto awaiter_h = h()` is ready to be consumed. This is acheived by calling `awaiter_h.await_ready()`. 

If `awaiter_h.await_ready()` returns `false` then we need to suspend the coroutine. This is acheived by updating the `suspend_address` to be just after the current   <span style="color:#d8a0df;">co_await</span> statement and calling `awaiter_h.await_suspend(frame)` which gives `awaiter_h` the responsibility to resume this coroutine whenever the value does become availiable. Finally we return from the current function, in this case back to the inital caller. Through some other mechanism `awaiter_h` will eventially have a value (or exception) and the the function body will be called again. This time the `goto suspend_address;` statement will jump us back to just after the `return;` that was taken last time, i.e. `Suspend_1`.

Alternatively, `awaiter_h.await_ready()` could have return `true` and the program would similarly be at the `Suspend_1` location. Regardless, at this point the result of `co_await h()` statement is ready and can be obtained by calling `awaiter_h.await_resume()`.

The `co_return i;` statement is handled by calling <span style="color:#4ec9b0;">promise_type</span>`.return_value(i);` and then immidiately proceeding to the so-called `final_suspend`. The role of `final_suspend` is to determine if the current <span style="color:#4ec9b0;">coroutine_frame</span> which contains the user's <span style="color:#4ec9b0;">promise_type</span> is safe to be deleted. Often it is prefered to not delete the frame at this time and instead allow the caller/consumer to delete the frame once they have obtained the result, i.e. `i` in this case.

## Issues and Solutions

The code given above should give you an inutition about what the compiler is doing. However, there are several issues.

### `goto suspent_point`
First is that standard C++ does not allow you to take the address of a `goto` label. To address this the `goto` statements can be replace with a `switch` statement. The function body would then look like
```C++
{
  switch(frame->suspend_point)
  {
  case SuspendPoint::InitialSuspend:
    // int i = co_await h();
    auto awaiter_h = h();
    if (!awaiter_h.await_ready()) {
        frame->suspend_point = (SuspendPoint)1;
        awaiter_h.await_suspend(frame);
        return;
    }
  case (SuspendPoint)1:
    int i = awaiter_h.await_resume();
  
    ...

  case SuspendPoint::FinalSuspend:
    delete frame;
  }
}
```
Using a switch statement is almost functionally equivalent. The main downside is that now users can not use switch statements across `co_*` keyworks (looking forward `CO_*` macros). Interestingly, switch statements allow for `case` locations what are in a nested scope, e.g. using can suspend in the middle of a for-loop and the switch statement can jump back to it on resume.
 
### Local variables
The second issue regards the saving the state of local variables between suspend and resume calls. For example, if before `co_await h()`  the user has construct some local variable and we suspended for `h()`, then when the function is resumed that local variable would be uninitialized.

The compiler handles this in the transformation by moving any declaration of local variables into the <span style="color:#4ec9b0;">coroutine_frame</span> as opposed to being the body of our lambda function. They are then destroyed when the coroutine completes.

While one can manually perform the transformation, we will instead consider an alternative solution. In particular, we will place/require all local variables to be declared in the lambda capture. While this results in slightly different symantics, it will enable us to write the <span style="color:#beb7ff;">CO_BEGIN</span> macro. 

A similar issue regards the lifetime of the awaiter when the coroutine is suspended, i.e. `awaiter_h` in the example above. This can be resolved by storing the awaiter either in a fixed sized buffer in <span style="color:#4ec9b0;">coroutine_frame</span> or allocating it on the heap if it is too large to fit in the buffer. 

### `std::coroutine_handle<promise_type>`
The final issue regards compatibility with C++20 coroutines. Ideally we can choose to implement our coroutines manually using the pattern outlined here or use the C++20 keywords. However, the primary barrier in achieving is that C++20 defines `<awaiter>.await_suspend` as taking a `std::coroutine_handle<promise_type>` as input while our example takes `<function-name>::coroutine_frame*`. 

Intuitively, these two parameters represent the same thing. Both are a pointer to the coroutine frame and provide a way for the awaiter to resume this coroutine once the thing being awaited becomes ready. However, the way we resume the `<function-name>::coroutine_frame` vs a C++20 coroutine are concretely different. Moreover, there is no way to convert our `<function-name>::coroutine_frame*` into a `std::coroutine_handle<promise_type>` since we can not modify that type. 

This issue could be resolved by giving <span style="color:#4ec9b0;">promise_type</span> another customization point which `std::coroutine_handle<promise_type>` interacts with and then dispatches to the correct method for resuming to coroutine. However, this is not part of the standard.

Instead, we will define our own `macoro::coroutine_handle<promise_type>` which can hold either a `std::coroutine_handle<promise_type>` or a `<function-name>::coroutine_frame*`. As such, our coroutines will only work with a <span style="color:#4ec9b0;">promise_type</span> that can take a `macoro::coroutine_handle<*>` as input to `<awaiter>.await_suspend(...)`.

This is somewhat unfortunent because thirdparty awaitable types which are intended for C++20 will most likely not work out of the box. However this is probable unavoidable given that they will likely take other dependancies to C++20.

### Allocations

The current stratagy requires several allocation. First we must allocate the <span style="color:#4ec9b0;">coroutine_frame</span>. C++20 defines a way to allow the user to control where this allocation happens. A description of it can be found in Luwis Baker's excelent [blog posts](https://lewissbaker.github.io/). A similar stategy can be applied to our framework with some modifcations. 

Another allocation likely occures for the <span style="color:#c8c8c8;">std</span><span style="color:#b4b4b4;">::</span><span style="color:#4ec9b0;">function</span><span style="color:#b4b4b4;">&lt;</span><span style="color:#569cd6;">void</span><span style="color:#b4b4b4;">(</span><span style="color:#569cd6;">void</span><span style="color:#b4b4b4;">)&gt;</span>. However, these is not required. We can instead define the function
```C++
template<typename lambda_type, typename promise_type>
coroutine_frame<lambda_type, promise_type>* makeFrame(lambda_type&& body);
```
that returns a frame that stores the function body with type `lambda_type` inside the <span style="color:#4ec9b0;">coroutine_frame</span>. Then the function body will take a pointer to the frame as its only parameter.

The final allocation is with respect to the storage of any awaiter that are produced during an active   <span style="color:#d8a0df;">co_await</span>. As suggested previously, these can be partially handled by having an additional buffer within the <span style="color:#4ec9b0;">coroutine_frame</span>. However, it is still possible that the coroutine body awaits an awaiter that does not fit in the buffer and then an allocation would occure. However, it is possible for this to result in a compile time error. This can then be combined with allows the buffer size to be an template parameter, i.e. an input to `CP_BEGIN`. 

Combining these we could obtain a coroutine that is garanteed to not to allocation any memory, something that C++20 coroutines can not currently achieve 100 percent of the time.

## Macros for Readability

Using the pattern above we can define the macros shown in the begining. A prototype of these ideas can be found in the [macoro](http://github.com/ladnir/macoro) repo. Below is a simplified definition of the main macros. In summary <span style="color:#beb7ff;">CO_BEGIN</span> begins the call to `makeFrame` that allocates the frame with the lambda containing the body being stored inline. The closing brace of the lambda/`makeFrame` function is in <span style="color:#beb7ff;">CO_END</span>. The first time we enter the inner function we finish the initial suspend (calling `await_resume` and destorying the awaiter). 

  <span style="color:#d8a0df;">co_await</span> first computes the type of the awaiter and then construct it within the frame (or on the heap). It then performs the `await_ready/await_suspend/await_resume` proceedure. If it does suspend, it updates the suspend point with the line index.

<span style="color:#beb7ff;">CO_END</span> first finishes the catch block, passing any exception to the <span style="color:#4ec9b0;">promise_type</span> and then performs the final suspend. This completes the definition of the inner function. <span style="color:#beb7ff;">CO_END</span> then completes the outter function by constructing the return object and starting the initial suspend. If ready we start the coroutine by calling the inner function and then return the return type. 

### <span style="color:#beb7ff;">CO_BEGIN</span>(return_type, ...)
```C++
using promise_type = return_type::promise_type;
using Handle = coroutine_handle<promise_type>;
// make frame with inline body.
auto frame = makeFrame<promise_type>(
  [__VA_ARGS__](frame_base<promise_type>* frame) mutable {

  promise_type& promise = frame->promise;
  try {
    // jump to where we suspended
    switch (frame->getSuspendPoint())
    {                                                  
    case SuspensionPoint::InitialSuspend:
    { // ------- initial suspend continued -------
      using Awaiter = typename awaiter_for<promise_type,
        decltype(promise.initial_suspend())>;  
      frame->get<Awaiter>().await_resume();
      frame->destroyAwaiter<Awaiter>();            
    } // -------- end of initial suspend ---------
    // ---------- begging of user code -----------
```

### <span style="color:#beb7ff;">CO_AWAIT</span>(RETURN_VAL, EXPR)
```C++
    { 
      using Awaiter = awaiter_for<promise_type, decltype(EXPR)>;
      {
        auto& awaiter = frame->constructAwaiter(EXPR);
        if (!awaiter.await_ready()) {
          // suspend-coroutine
          frame->setSuspendPoint((SuspensionPoint)__LINE__);

          // call awaiter.await_suspend(). If it's void return, then return true.
          if (await_suspend(awaiter, Handle::from_promise(promise))) 
            return;
        }
      }
      // resume-point, __LINE__ will be the same in macro.
    case SuspensionPoint(__LINE__):
      RETURN_VAL = frame->get<Awaiter>().await_resume();
      frame->destroyAwaiter<Awaiter>();
    }
```
### <span style="color:#beb7ff;">CO_END</span>()
```C++
    // ---------- end of user code -----------
    default:
    }
  } catch (...) {
    frame->promise.unhandled_exception();
  }

  // ---------- begging of final suspend -----------
  using Awaiter = typename awaiter_for<promise_type, decltype(promise.final_suspend())>;
  auto& awaiter = frame->constructAwaiter(promise.final_suspend());
  auto handle = Handle::from_promise(promise);
  if (!awaiter.await_ready()) {
    // suspend-coroutine
    frame->setSuspendPoint(SuspensionPoint::FinalSuspend);
    // call awaiter.await_suspend(). If it's void return, then return true.
    if (await_suspend(awaiter, handle))
      return;
  }
  frame->get<Awaiter>().await_resume();
  frame->destroyAwaiter<Awaiter>();
  handle.destroy();
  // ---------- end of final suspend -----------
});

auto ret = frame->promise.get_return_object();

// ------- begging of initial suspend ----------
using Awaiter = awaiter_for<promise_type, decltype(promise.initial_suspend())>;
auto& awaiter = frame->constructAwaiter(promise.initial_suspend());
auto handle = Handle::from_promise(promise);
if (!awaiter.await_ready())
{
  // suspend-coroutine
  frame->setSuspendPoint(SuspensionPoint::InitialSuspend);
  //call awaiter.await_suspend(). If it's void return, then return true
  if (await_suspend(awaiter, handle))
    return ret;
}

/*begin coroutine*/
(*frame)(frame);
return ret;

```
